/*
 * Copyright (c) 2009 Aarhus University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the
 *   distribution.
 * - Neither the name of Aarhus University nor the names of
 *   its contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL AARHUS
 * UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @author Morten Tranberg Hansen <mth at cs dot au dot dk>
 * @date   October 18 2009
 */

module AMBlockReceiverP @safe() {

	provides {
		interface Init;
		interface BlockReceive;
	}

	uses {
		interface Leds;

		interface Receive as SubReceive;
		interface CC2420PacketBody;
		interface Packet;
		interface AMPacket;
		interface BlockPacket;

		interface NeighborTable;
		interface Neighbor;
		interface BlockNeighbor;

		interface Pool<message_t> as ReceivePool;
	}

} implementation {

	uint8_t get_number(neighbor_t* n, uint8_t seqno);
	void init(neighbor_t* n, uint8_t start, uint8_t size);
	message_t* add(neighbor_t* n, uint8_t number, message_t* msg);
	void arrive(neighbor_t* n);

	/***************** Init ****************/

	command error_t Init.init() {
		return SUCCESS;
	}

	/***************** BlockReceive ****************/

	command void BlockReceive.receiveDone(message_t** ONE msgs, uint8_t size) {
		uint8_t i;
		for(i=0; i<size; i++) {
			if(msgs[i]!=NULL) {
				call ReceivePool.put(msgs[i]);
			}
		}
	}

	/***************** SubReceive ****************/

	event message_t* SubReceive.receive(message_t* msg, void* payload, uint8_t len) {
		neighbor_t* n = call NeighborTable.get(call AMPacket.source(msg));
		uint8_t seqno = (call CC2420PacketBody.getHeader(msg))->dsn;
		uint8_t number;

		/*time_stop();
			printf("receve %lu\n", time_get());*/

		if(n==NULL) {
			uint8_t i;
			printf("NEIGHBOR %hhu IS NULL!!!\n", call AMPacket.source(msg));

			printf("Table: ");
			for(i=0; i<call NeighborTable.numNeighbors(); i++) {
				printf("%hu, ", call Neighbor.getAddress(call NeighborTable.getById(i)));
			}
			printf("\n");
			
			call Leds.led0On();
			call Leds.led1On();
			call Leds.led2On();
			return msg;
		}

		//printf("packet seqno:%hhu, req:%hhu\n", call BlockPacket.getSequenceNumber(msg), call BlockPacket.getRequest(msg));

		if(call BlockNeighbor.getIsReceived(n)) {
			init(n, call BlockPacket.getSequenceNumber(msg), call BlockPacket.getRequest(msg));
			printf("init %hhu\n", call Neighbor.getAddress(n));
		}

		number = get_number(n, seqno);

		//printf("receive n:%hhu, r:%hhu\n", number, call BlockNeighbor.getReserved(n));

		while(number>=call BlockNeighbor.getReserved(n)) {
			printf("late %hhu, seqno:%hhu, start:%hhu\n", call Neighbor.getAddress(n), seqno, call BlockNeighbor.getStartSequenceNumber(n));
			arrive(n);
			init(n, call BlockPacket.getSequenceNumber(msg), call BlockPacket.getRequest(msg));
			number = get_number(n, seqno);
		}

		msg = add(n, number, msg);
		
		if(number==(call BlockNeighbor.getReserved(n)-1)) {
			printf("normal %hhu, seqno:%hhu, start:%hhu\n", call Neighbor.getAddress(n), seqno, call BlockNeighbor.getStartSequenceNumber(n));
			arrive(n);
		}

		return msg;

	}

	/***************** NeighborTable ****************/

	event void NeighborTable.evicted(am_addr_t addr) {

		printf("************** EVICTED\n");

	}

	/***************** Functions ****************/

	uint8_t get_number(neighbor_t* n, uint8_t seqno) {
		uint8_t start = call BlockNeighbor.getStartSequenceNumber(n);
		if(seqno>=start) {
			return seqno-start;
		} else {
			return seqno + (256 - start);
		}
	}

	void init(neighbor_t* n, uint8_t start, uint8_t size) {
		call BlockNeighbor.setStartSequenceNumber(n, start);
		call BlockNeighbor.setReserved(n, size);
		call BlockNeighbor.clearReceived(n);
		call BlockNeighbor.setIsReceived(n, FALSE);
		call BlockNeighbor.setTimeout(n, 0); // setTimeout is used as full counter
		debug_event1(DEBUG_RECEIVE_INIT, call Neighbor.getAddress(n));
	}

	message_t* add(neighbor_t* n, uint8_t number, message_t* msg) {
		message_t* empty = call ReceivePool.get();
		if(empty!=NULL) {
			debug_event1(DEBUG_RECEIVE_AM, call Neighbor.getAddress(n));
			call BlockNeighbor.setMessage(n, number, msg);
			call BlockNeighbor.setReceived(n, number);
			//printf("r%hhu n:%hhu\n", call Neighbor.getAddress(n), number);
			return empty;
		} else {
			//printf("FULL\n");
			// setTimeout is used as full counter
			call BlockNeighbor.setTimeout(n, 1 + call BlockNeighbor.getTimeout(n)); 
			//debug_event1(DEBUG_RECEIVE_AM_FULL, call Neighbor.getAddress(n));
			return msg;
		}
	}

	void arrive(neighbor_t* n) {

		if(!call BlockNeighbor.getIsReceived(n)) {
			uint8_t i;
			uint8_t c = 0;
			message_t* ONE_NOK msgs[call BlockNeighbor.countReceived(n)];
			
			for(i=0; i<call BlockNeighbor.getReserved(n); i++) {
				message_t* m = call BlockNeighbor.getMessage(n, i);
				if(m!=NULL) {
					msgs[c] = m;
					c++;
				} else {
					//printf("LOST\n");
					//debug_event1(DEBUG_RECEIVE_AM_LOST, call Neighbor.getAddress(n));
				}
				call BlockNeighbor.setMessage(n, i, NULL);
			}
			
			if(c!=call BlockNeighbor.countReceived(n)) {
				printf("**** RX c:%hhu, count:%hhu\n", c, call BlockNeighbor.countReceived(n));
			}
			
			printf("arrive %hhu\n", call BlockNeighbor.countReceived(n));

			signal BlockReceive.receive(msgs, call BlockNeighbor.countReceived(n), call Packet.payloadLength(msgs[0]));
			call BlockNeighbor.setIsReceived(n, TRUE);
			debug_event4(DEBUG_RECEIVE_ARRIVED, call Neighbor.getAddress(n), call BlockNeighbor.getReserved(n), call BlockNeighbor.countReceived(n), call BlockNeighbor.getTimeout(n));

		}

	}


}

/*

	event message_t* SubReceive.receive(message_t* msg, void* payload, uint8_t len) {
		uint8_t seqno = (call CC2420PacketBody.getHeader(msg))->dsn;
		uint8_t number = get_number(seqno);

		while(get_number(seqno)>=BUFFER_SIZE) {
			debug_event(DEBUG_RECEIVE_ARRIVED);
			start += BUFFER_SIZE;
			printf("late seqno:%hhu, start:%hhu\n",seqno,start);
		}
		
		debug_event(DEBUG_RECEIVE_AM);
		printf("r s: %hhu, n:%hhu\n", seqno, number);
		
		if(number==BUFFER_SIZE-1) {
			debug_event(DEBUG_RECEIVE_ARRIVED);
			start += BUFFER_SIZE;
			printf("normal seqno:%hhu, start:%hhu\n",seqno,start);
		}

		return signal Receive.receive(msg, payload, len);		

	}
*/
